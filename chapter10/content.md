# **브라우저와 Node.js간에 코드를 공유하는 방법**
- **이기종 환경 간의 불일치** (Node.js에서 사용하는 모듈 시스템, 브라우저에서 사용되는 모듈 시스템)   
브라우저에는 require()함수나 모듈을 해결할 수 있는 파일 시스템이 없다.

- **서버와 브라우저에 대한 코드 배포의 차이점**  
서버: 모듈은 fs에서 직접 로드. (성능 요구, 작고 체계적인 단위 필수)

- **브라우저에서 스크립트를 적재하는 모델**    
엔드 포인트에서 HTML 페이지를 다운로드=구문분석=>필요한 페이지 또 요청    
해결1) HTTP/2 Server Push, 클라이언트 측의 캐싱, 사전로드    
해결2) **번들(브라우저용 패키지)** 를 빌드하는 것  

## **모듈 번들러**
애플리케이션의 소스 코드를 가져와 하나 이상의 번들 파일을 생성하는 도구    
* 브라우저가 로드해야 할 **총 파일 수를 줄여준다**.    
* Babel과 같은 **트랜스파일러를 사용**할 수 있다.     
    * 트랜스파일러?    
    소스코드를 처리해서 최신 JS 구문을 ECMAScript5구문으로 변환하여 다양한 브라우저에서 애플리케이션을 올바르게 실행할 수 있도록 하는 도구    
> p.397그림, 설명 참고   

**서버** : 빌드 단계가 필요하지 않고 **소스코드를 직접 실행**할 수 있다.      
**브라우저** : **빌드와 런타임**을 처리한다.

### **1. 종속성 해결** 
진입점에서 시작하여 모든 종속성을 발견해서 종속성 그래프(비순환 직접 그래프)로 나타낸다.   
모듈맵이라는 데이터 구조를 만든다.     
### **2. 패킹**
모듈맵을 가져와서 단일 JavaScript 파일인 실행ㅎ 가능한 번들로 변환한다.   

# **크로스 플랫폼 개발의 기초**
## **1. 런타임 코드 분기**
두 플랫폼의 코드는 동일한 모듈에 포함되어 있다.=>런타임 변수의 값을 알 수 없으므로 어느것이 사용될 지 모른다.=>최종 번들에 포함된다.=>사용되지 않는 불필요한 코드를 추가시켜 번들의 크기를 증가시킨다.=>사용되지 않는 코드에 암호화 키나 API 키 값이 사용자의 브라우저로 전송하면 안되는 중요한 정보가 포함되어 있을 수도 있다.=>심각한 보안 문제를 초래할 수 있다.    
## **2. 빌드시 코드 분기**
웹팩은 플러그인을 지원하므로 웹팩의 기능을 확장하고, 번들 파일을 생성하는 데 새로운 처리 단계를 추가하여 번들 파일을 생성할 수 있다. **빌드시 코드 분기**를 수행하기 위해서는 DefinePlugin이라는 내장 플러그인과 terser-webpack-plugin이라는 외부 플러그인을 활용할 수 있다.   

# **크로스 플랫폼 개발을 위한 디자인 패턴**
- 전략 및 템플릿  
브라우저와 코드를 공유할 때 유용한 패턴   
알고리즘의 공통 단계를 정의하여 일부 부분을 교체할 수 있도록
- 어댑터  
전체 컴포넌트를 교체해야 할 때   
- 프록시  
서버에서 실행되는 코드가 브라우저에서 사용될 수 있도록 서버에서 사용되는 기능들이 필요한 경우 
- 종속성 주입 및 서비스 로케이터


-----------------------------
------------------------------

# **React**
* 컴포넌트 개념에 초점을 맞추어 뷰의 추상화를 제공한다.**재사용이 높은 컴포넌트를 정의** 하고 구성하여 사용자 인터페이스를 구성한다.
* DOM에 바인딩되지 않는다. **가상DOM**이라는 추상화를 제공한다.   

p.415 line5~  

* **싱글 페이지 애플리케이션(SPA)**   
: 최초의 랜더링이 대부분 서버에서 일어난다. 그후, 변경해야 할 페이지의 부분만 동적으로 새로 고쳐지고, 전체 페이지에 대한 재로딩이 필요없다.   
SEO(향상된 검색 엔진 최적화)/ 성능 향상   

props.match.pararms.authorId ; p.432  
URL의 authorId를 가져오는 역할.  authorId를 이용해서 페이지에 필요한 data를 가져온다.  


# 미리 로드해야 하는 데이터를 파악하는데 사용할 수 있는 방법 2가지
## **1. Two-Pass 렌더링**

> intentionally need to render something different on the server and the client, you can do a two-pass rendering.  
  the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration    
https://reactjs.org/docs/react-dom.html#hydrate 

p.446   
+a Multi-Pass 렌더링    
## **2. 비동기 페이지**
서버에 요청을 보내고 데이터를 받아 사용하는 페이지?!?!   