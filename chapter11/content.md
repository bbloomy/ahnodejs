# **확장성과 아키텍처 패턴**
## **애플리케이션 확장 소개**
작업 부하를 확장할 수 있는 기술을 사용함으로써 고가용성 및 장애내성을 얻을 수 있다.    

## **확장성 3차원**  
### **부하 분산** : 여러 프로세스와 머신에 걸쳐 애플리케이션의 로드를 분할하는 것   
> **스케일 큐브**  
**x축 - 복제**   
동일한 애플리케이션을 n번 복제하고, 각 인스턴스가 1/n의 부하를 처리할 수 있도록 하는 것. 
시간 비용 저렴.   
**Y축 - 서비스/기능별 분해**    
기능, 서비스 또는 사용 사례에 따라 애플리케이션을 분해하는 것.   
ex1) 관리를 담당하는 애플리케이션을 사용자에 노출되는 공개 애플리케이션과 분리하는 것.  
ex2) 사용자 인증을 담당하는 서비스를 추출하여 전용 인증 서버를 만드는 것.   
ex3) 마이크로서비스는 세분화된 Y축 확장과 관련된 용어이다.  
**Z축 - 데이터 파티션으로 분할**      
각 인스턴스가 전체 데이터의 일부만 담당하는 방식으로 애플리케이션이 분할되는 것.   
수평/수직 분할이라고도 하는데, DB에서 자주 사용된다.   
동일한 애플리케이션의 여러 인스턴스가 있으며 각 인스턴스는 서로 다른 기준을 사용하여 결정되는 데이터 파티션에서 작동한다.  
ex) 범위 분할 / 해시 분할 후, 각 파티션을 애플리케이션의 특정 인스턴스에 할당할 수 있다. 
데이터 파티션을 사용하려면 지정된 데이터를 담당하는 애플리케이션 인스턴스를 판별하기 위한 조회 단계가 선행되어야 한다.   
데이터 파티셔닝은 대규모 모놀리식 데이터 셋 처리와 관련된 문제를 해결하는 것이 주 목적이기 때문에 일반적으로 데이터 스토리지 수준에서 적용 및 처리된다.   
애플리케이션 수준에서 적용하는 것은 복잡한 분산형 아키텍쳐 또는 데이터의 지속성을 위해 외부 솔루션에 의존하는 애플리케이션을 만드는 경우, 파티셔닝을 지원하지 않는 데이터베이스를 사용하는 경우, 또는 Google 스케일에서 애플리케이션을 만드는 경우와 같이 특별한 사용 사례에서만 고려할 가치가 있다.   

## **복제 및 로드 밸런싱**
```
애플리케이션을 확장하기위한 전제 조건은    
    각 인스턴스가 메모리나 디스크와 같이 공유할 수 없는 리소스에 공통정보를 저장할 필요가 없어야 한다는 것이다.
```
ex) 웹 서버에서 세션 데이터를 메모리나 디스크에 저장하는 것 : 확장에 적합하지 않다.    
공유 데이터 베이스를 사용 : 배포된 위치에 관계없이 각 인스턴스가 동일한 세션 정보에 접근할 수 있다. 
### **[1] 클러스터 모듈**
Node.js에서 단일 머신에서 실행되는 **여러 인스턴스에 애플리케이션 부하를 분산하는 가장 간단한 패턴**은 코어 라이브러리의 일부인 cluster 모듈을 사용하는 것이다. **cluster 모듈**은 동일한 애플리케이션의 새 인스턴스 분기를 단순화하고 들어오는 연결을 자동으로 배분한다. 대부분 클러스터 모듈에서 **라운드 로빈 로드 밸런싱 알고리즘**을 사용한다.   
* **마스터 프로세스** : 확장하려는 애플리케이션의 인스턴스를 각각 나타내는 여러 프로세스를 생성한다. 수신되는 각 연결은 복제된 작업자에 분산되어 부하를 분산시킨다.   
모든 작업자는 독립적인 프로세스이므로, 시스템에서 사용 가능한 CPU 수만큼 작업자를 생성할 수 있다. 이 접근 방식은 Node.js 애플리케이션이 시스템에서 사용할 수 있는 모든 컴퓨팅 성능을 쉽게 활용할 수 있다.   


### 클러스터 모듈의 이용1 _ **다운 타임 제로 재시작**
애플리케이션을 업데이트 하기 위해 다시 시작해야 하는 경우 요청을 처리할 수 없는 작은 간격이 있다.  
SLA(Service-Level Agreement)가 있는 전문 애플리케이션이나 지속적인 배포 프로세스의 일부로 매우 자주 업데이트 되는 애플리케이션은 업데이트하기 위해 애플리케이션을 재시작할 수 없다.   

>**다운 타임 없이 재시작을 구현하자**

클러스터 모듈 패턴에는 한 번에 하나씩 작업자를 다시 시작한다. 이러한 방식으로 나머지 작업자는 계속해서 애플리케이션 서비스를 운영하고 유지할 수 있다. 이 기능을 클러스터된 서버에 추가해본다. 해야 할 일은 마스터 프로세스가 실행할 새로운 코드를 추가한다.   

### 클러스터 모듈의 이용2 _ **상태 저장 통신 다루기**
인증 요청을 처리해주는 애플리케이션이 여러 개일 때, 상태를 공유하지 않는다면 인스턴스A에서 인증을 받았음에도 인스턴스B에서 인증을 계속 받아야 하는 문제가 있다.

>**방법1. 여러 인스턴스에서 상태를 공유하자**   
공유 DB 저장소를 사용하거나 , Redis, Memcached 같은 메모리 저장소를 사용하자.    

이 패턴을 사용하려면, 기존 코드에서 공유 저장소를 사용하도록 라이브러리를 설정, 교체 또는 구현해야 한다.  
애플리케이션의 확장성을 개선하는 데 너무 많은 변경이 필요하거나 주어진 시간 제약으로 리팩토링이 불가능한 경우, 고정 로드 밸런싱(고정 세션)을 사용할 수 있다

>**방법2. 고정 로드 밸런싱**   
: 로드 밸런스가 세션과 관련된 모든 요청을 항상 동일한 애플리케이션 인스턴스로 라우팅하도록 하는 것   

로드 밸런서는 새 세션과 관련된 요청을 수신하면, 로드 밸런싱 알고리즘에 의해 선택된 **특정 인스턴스로 맵핑**을 생성한다. 다음에 로드 밸런서가 동일한 세션에서 요청을 수신하면 **로드 밸런싱 알고리즘을 우회하여 이전에 세션과 연결된 애플리케이션 인스턴스를 선택한다.**(세션 ID 이용_애플리케이션이나 로드 벨런서 자체의 쿠키에 포함된) 

or

자주 IP를 변경하지 않는 장치라면, 클라이언트 IP 주소를 해시하여 수신할 애플리케이션의 인스턴스를 사용할 수도 있다.   
: ) 로드벨런서가 연결과 관련된 정보를 저장할 필요가 없다.   


>고정 로드 밸런싱의 문제
애플리케이션의 모든 인스턴스가 동일하고 다른 인스턴스들이 작동을 멈춘 다른 인스턴스를 대체할 수 있다는 장점을 무효화시킨다. 그러므로, 고정 로드 밸런싱을 피하고 공유 저장소에서 세션 상태를 유지하는 애플리케이션을 만들어라  

### **[2] 역방향 프록시 확장**
**클러스터 사용의 대안이다.**   
서로 다른 포트 또는 머신에서 실행되는 동일한 애플리케이션의 여러 독립 실행형 인스턴스를 시작한 다음, 역방향 프록시를 사용하여 해당 인스턴스들에 대한 접근을 제공하여 트래픽을 분산하는 것이다.    

* Node.js 애플리케이션이 클러스터 모듈 대신 이 접근 방식을 선택해야 하는 많은 이유가 있다.   
    * 역방향 프록시는 여러 프로세스뿐만 아니라 **여러 시스템에 부하를 분산**할 수 있다.   
    * 시장에서 가장 널리 사용되는 역방향 프록시는 **고정 로드 밸런싱을 지원**한다.
    * 역방향 프록시는 프로그래밍 언어 또는 플랫폼에 관계 없이 **사용 가능한 모든 서버로 요청을 라우팅**할 수 있다.   
    * 보다 강력한 로드 밸런싱 알고리즘을 선택할 수 있다.   
    * 많은 역방향 프록시는 URL 재작성, 캐싱, SSL 종료 지점, 보안 기능과 같은 **추가적인 강력한 기능과 정적 파일 제공과 같이 사용할 수 있는 완전한 웹서버의 기능을 제공**한다.

* 역방향 프록시를 사용하여 로드 밸런싱을 구현할 수 있는 예시   
    * Nginx
    * HAProxy
    * Node.js기반 프록시
    * 클라우드 기반 프록시   

> 애플리케이션 인스턴스 시작, nginx.conf에 로드 밸런서 적용  (이거 할 수 있을듯?!?!)

### **[3] 동적 수평 확장**
클라우드 기반 인프라 장점 : 애플리케이션의 용량을 동적으로 조장할 수 있다.   
로드 밸런서는 항상 현재 네트워크 토폴로지를 최신 상태로 유지하고 어느 서버가 작동 중인지 알고 있어야 한다.   

> **서비스 레지스트리 사용**  
API와 웹 앱이 있을 때
서비스 인스턴스들은 여러 서버에 분산되어 하나 이상 존재할 수 있다.  
요청이 수신되면, 로드 밸런서는 요청 경로의 앞부분을 확인하여 /api인 경우, 요청을 API서비스들 중 지금 사용할 수 있는 인스턴스 중 한 군데로 전달함으로써 부하를 분산시킨다.    
트래픽 부하를 분산하는 데 유용하지만 실행중인 서버에서 서비스 인스턴스를 분리할 수 있다는 추가적인 장점이 있다. 서비스 레지스트리 패턴은 네트워크 서비스에 적용된 서비스 로케이터 지아니 패턴의 구현이다.   

### **[4] 피어 투 피어 로드 밸런싱**
로드 벨런서를 없애고, 클라이언트 서비스A가 직접 요청을 하는 것..  
서비스 A가 서비스 B를 노출하는 서버에 대한 세부 정보를 알고 있는 경우에만 가능하다.    

네트워크 노드를 제거하여 인프라 복잡성이 감소하다.  
더 빠른 통신이 가능하다.
로드 벨런서의 성능에 제한되지 않으므로 확장성이 개선된다.   

ex) 여러 서버에 요청을 분산할 수 있는 HTTP 클라이언트(p.544)

### **[5] 컨테이너를 사용한 애플리케이션 확장**   
컨테이너? - Docker  
Kubernetes? - 컨테이너 오케스트레이션 도구 (p.550)  
컨테이너 오케스트레이터 플랫폼을 사용할 경우, 여러 인스턴스로 확장하거나 소프트롤아웃 및 애플리케이션의 재시작을 처리하는 것과 같은 문제를 애플리케이션이 신경쓸 필요가 없기 때문에 코드를 간단하게 유지할 수 있다.

-------------
위는 주로 x 축에서의 분석이었음

앞으로는 기능/서비스별로 분해할 것임(Y축) => 애플리케이션의 용량 뿐만 아니라 복잡성도 확장할 수 있다.   

------------

## 모놀리식 아키텍처
컴포넌트 중 하나라도 실패하면 전체 시스템이 영향을 받는다.     
(p.558)

## 마이크로서비스 아키텍쳐
각 컴포넌트를 자체 데이터베이스와 함께 자체 컨텍스트가 존재하는 자립적이고 독립적인 애플리케이션으로 만들자.  

서비스의 데이터 소유권은 마이크로서비스 아키텍처의 중요한 특성이다. 
서비스자 동일한 데이터베이스를 공유하지 않기에 전체 시스템의 일관성을 유지하기 위해 많은 통신이 필요하다.   
장점 : ) 충돌이 전체 시스템에 전파되지 않는다. 
커다란 모놀리식 애플리케이션을 작은 서비스로 분할하면 쉽게 재사용할 수 있는 독립적인 단위를 만들 수 있다.

ex) Elasticsearch는 재사용 가능한 검색 서비스의 좋은 예이다.  
ex) ORY는 마이크로서비스 아키텍처에 쉽게 톻합할 수 있는 완전한 인증 및 권한 부여 서비스를 제공하는 재사용 가능한 오픈 소스 기술의 또 다른 예이다.

:) 정보 숨김 수준이 모놀리식 애플리케이션에 비해 훨씬 높다. 

웹 API 또는 메시지 브로커와 같은 원격 인터페이스를 통해 발생하기 때문에 가능하다.   
서비스 구현 또는 배포 방식의 변경으로부터 클라이언트를 보호할 수 있다.  
클라이언트는 인프라가 확장되는 방식, 사용하는 프로그래밍 언어, 데이터 저장에 사용하는 데이터 베이스로 부터 보호된다.   
(p.560사진)

## 마이크로서비스 아키텍처의 통합 패턴
마이크로서비스 아키텍쳐에서는 모든 노드를 연결하여 공동작업을 수행하는 것이 어렵다.     

## API 프록시
여러 API 엔드포인트에 단일 엑세스 포인트를 제공하는 것이지만, 로드 밸런싱, 캐싱, 인증 및 트래픽 제한을 제공할 수도 있으며 이 모든 기능은 견고한 API 솔루션을 구현하는데 매우 유용하다.    
복잡한 마이크로서비스 인프라에 대해 단일 뷰를 제공한다.(p.564)  
다양한 서비스를 자유롭게 재구성할 수 있다.   

## API 오케스트레이션
서비스들을 통합하고 구성하는 방법.   
사용예시 1. 세가지 다른 서비스의 세가지 연산을 가지고, 전체 시스템을 일관된 상태로 유지하기 위해 서비스를 조정할 수 있는 새로운 API를 만들었다.     
사용예시 2. API 오케스트레이션 게층에서 데이터 집계를 수행한다.   

completedCheckout()이 서로 다른 세 단계로 구성된 복합 연산으로 구성된 것을 보여준다. (p.567사진)

API 프록시와 유사하지만, 오케스트레이터는 다양한 서비스의 의미 통합을 수행하고 기본 서비스에 노출된 것과 다른API를 노출하기도 한다. 
## 메시지 브로커와의 통합
> 서비스간의 직접적인 관계를 만들 되, 구성된 모든 서비스를 분리된 상태로 유지하자. 모든 서비스는 시스템에 나머지 서비스들 없이도 혹은 새로운 서비스 및 노드와 결합해도 잘 작동할 수 있어야 한다.     
해결책> 메시지 수신자로부터 발신자를 분리할 수 있는 시스템인 메시지 브로커를 사용하여 중앙 집중식의 발행/구독 패턴을 구현하자.(p.568 사진)    
